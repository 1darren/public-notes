# Data Structure

## Linked List

### Key differences with lists;
1. There are no indexes; each node points to the next node
   - Because nodes are not adjacent, we cannot have addresses
   - Because there are no addresses, we cannot find the node by using the index
2. 2 additional pointers; starts with a `head`, ends with a `tail`
   - The `tail` points to `None`

#### Append & Pop / Removing or Adding to the Final Node: O(n)
   -  `Tail` must point to the new last node
   -  New last node must point to zero 
-  But, because there are no indexes...
   -  We can't
   -  We can't just jump to the final node; 
   -  First we set the new last node to point to zero
   -  Then, we iterate through the entire list to point at the last node
   -  This activity is O(n)


#### Prepend: Adding Item at the Top: O(1) 
- This operation has constant time;
   - First, point New Head at previous Head
   - Then, point `head` at New Head
   - Does not iterate through list, is constant

#### Pop First: Removing Item at the Top: O(1) 
- Similarly, this function runs in constant time;
   - Point `head` at New Head
   - Remove item from Linked List


#### Adding/Removing Item in the Middle: O(N) 
- There's no way to find a specific node; so must iterate through the list
- To add is O(n)
   - e.g. to replace a "3", must iterate through the list to find the "3" node
   - newnode.next = 3.next, then
   - 3.next = newnode
 - Similarly, to remove is O(n)
   - previousnode.next = removednode.next
   - remove removednode

#### Lookup by Index or Search: O(N) 
- There's no way to find a specific node; so must iterate through the list


### Linked Lists vs Lists
- Some features are the same for Linked Lists & Lists 
   - Append O(1)
   - Insert, Remove, Lookup by Value O(n)
- Linked Lists take longer if traverse...
   - Pop, Lookup by Index is O(n) for LL and O(1) for L
- ...but faster at the head of the LL
   - Prepend, Pop First is O(1) instead of O(n) for L (need to re-index everything

---------
### Understanding a Node
- A node in a Linked List is 2 parts; `value` & `next`
- Almost like a dictionary;
   ![image](https://user-images.githubusercontent.com/24678048/160831361-527fb3d8-a2cd-4f9b-80ac-cf9e86792379.png)   

- But also, a Linked List can be thought of as nested brackets; with `head` pointing to the first brackets and `tail` pointing to the innermost bracket

![image](https://user-images.githubusercontent.com/24678048/160831470-5a1c96eb-5ccf-4b35-a64e-96ff9dfc918d.png)

### Constructing a Linked List
- We start with creating a `Node` class; 
- Nodes are the building blocks of Linked Lists
``` 
class Node:                            # initializing the node class
   def __init__(self, value):          # creates Node-unique methods of value & next
      self.value = value
      self.next = None


class LinkedList:                      # initializing the LL class, defining its attributes
   def __init__(self, value): 
      new_node = Node(value)           # calls the Node class, passing 'value' to the value of class
      self.head = new_node
      self.tail = new_node
      self.length = 1
      
```
- Now, we can create a new linked list
   - This creates the LinkedList with a value of 4
   - We can then `print(my_linked_list.head.value)` which should output 4
![image](https://user-images.githubusercontent.com/24678048/160833259-64113752-81f1-4972-9d9a-aa081ce682e6.png)


```
my_linked_list = LinkedList(4)
```

In the background, these methods apply:
- my_linked_list.head.value = 4
- my_linked_list.tail.value = 4
- my_linked_list.head.next == None == my_linked_list.tail.next
- my_linked_list.length = 1

```
def print_list(self): 
   temp = self.head
   while temp is not None:
      print(temp.value)
      temp = temp.next
      
print_list(my_linked_List)
--> prints(4)
```







### Creating LL Methods
- Append is relatively easy if the LL is not empty;
- But there is an edge case: if LL is empty, 
    - both `head` and `tail` point to None
    - this is more complicated...

![image](https://user-images.githubusercontent.com/24678048/160833829-2d21c2cb-c03e-4bfe-b8ea-80a4c8e586b1.png)


```
class LinkedList:                   
    def append(self, value):           # defining methods that work with new class
      new_node = Node(value)
    
    
      if self.head is None: 
         self.head = new_node
         self.tail = new_node
       else:
         self.tail.next = new_node
         self.tail = new_node
      self.length += 1
      
      return True                      # Optional 
    
    
    def prepend(self, value):          # defining methods that work with new class
    def insert(self, index, value):    # defining methods that work with new class
```

In action, it'd look like...

```
my_linked_list = LinkedList(1)
my_linked_list.append(2)
my_linked_list.print_list()
--> 1 /n 2
```


```
class LinkedList:                   
    def pop(self):           # defining methods that work with new class
      if self.length == 0:
         return None
       else:
         temp = self.head
         pre = self.head
         while (temp.next):         # this statement runs while temp.next is not None
         if self.head.next is None:
            returnvalue = self.head
            self.head = None
            self.tail = None
            self.length = 0
            return returnvalue
         else:
            temp = self.head
            while temp.next.next is not None:
               temp = temp.next
            returnvalue = temp.next
            self.tail = temp
            self.tail.next = None
            self.length -= 1
            return returnvalue
```
